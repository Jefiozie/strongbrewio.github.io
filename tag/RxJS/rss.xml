<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>blog.strongbrew.io</title>
   
   <link>https://blog.strongbrew.io/</link>
   <description></description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>RxJS patterns - restarting work</title>
	  <link>//rxjs-patterns-restarting-work/</link>
	  <author></author>
	  <pubDate>2019-01-05T00:00:00+00:00</pubDate>
	  <guid>//rxjs-patterns-restarting-work/</guid>
	  <description><![CDATA[
	     <p>Having used RxJS for a while now, I’ve started to see patterns that I’m using over and over again. In this blogpost, or better, series of blogposts, I want to share those patterns that I’m frequently using so that you can apply them in your own code.</p>

<p>I’ll do this by describing them as high level as possible, but still provide you with some examples on where they can be applied.</p>

<h2 id="what-is-work">What is ‘work’?</h2>

<p>When conducting interviews and discussing RxJS, I tend to ask people how they would describe an <code>Observable</code> in only a couple of sentences. I’m well aware that this is difficult and quite hard to describe. Here is my personal attempt:</p>

<blockquote>
  <p>An <code>Observable</code> is a wrapper around some work. That work can be triggered by subscribing in response to which one or multiple results can be pushed towards us. This might happen both synchronously and asynchronously.</p>
</blockquote>

<p>The reason I’m mentioning this is because it will help me in explaining what I mean with the term ‘work’ in the context of an <code>Observable</code>. Whatever is being triggered by subscribing to an <code>Observable</code> is something that I will refer to as ‘work’.</p>

<h2 id="why-do-we-need-to-restart-work">Why do we need to restart work?</h2>

<p>Let’s say that we have an <code>Observable</code> whose ‘work’ is actually triggering a backend call. We might want to execute this backend call multiple times, hence we want the ‘work’ that this specific <code>Observable</code> does to be executed multiple times.</p>

<p>Thanks to the fact that <code>Observables</code> are cold by default, we can accomplish this by subscribing to this <code>Observable</code> multiple times. Every subscription will trigger a backend call.</p>

<h2 id="how-can-we-do-this">How can we do this?</h2>

<h3 id="non-reactive">Non reactive</h3>

<p>A non-reactive solution to do so could be wrapping the subscription in a function and calling it over and over again every time we wish to subscribe.</p>

<pre><code class="language-typescript">const executeBackendCall = () =&gt; {
	this.someObs$.subscribe((result) =&gt; {
	   // do something here
	}
}
</code></pre>

<p>But this obviously has some downsides to it. Aside from the fact that is not reactive, we have a subscription to manage for every function call, we can no longer chain this with other operators (as we manually subscribe), and so on.</p>

<h3 id="reactive">Reactive</h3>

<p>We want to implement this in a more reactive way. We can do this by no longer thinking in terms of function calls but in term of a series of triggers where we want to do something. We need a stream that is triggered every time we want a certain action to occur.</p>

<p>Let’s assume we have such a stream. Whenever that stream fires, we want to do some ‘work’. Remember that ‘work’ is something that is encapsulated in an <code>Observable</code>.</p>

<p>Translated to code this means that we want to map a next event to an <code>Observable</code>.</p>

<pre><code class="language-typescript">const work$: Observable&lt;T&gt; = ...
const trigger$ = ...

const workExecutedOnTrigger$: Observable&lt;Observable&lt;T&gt;&gt; = trigger$.pipe(
	map(triggerValue =&gt; work$)
);
</code></pre>

<p>In this piece of code we have an <code>Observable</code> called <code>work$</code>, containing the ‘work’ we want to do when the <code>trigger$</code> fires. 
We can create a new stream called <code>workExecutedOnTrigger$</code> that maps the trigger event to the <code>work$</code>.</p>

<p>The problem with this code is that the result of this action is an <code>Observable&lt;Observable&lt;T&gt;&gt;</code> (also called a higher order observable) whilst we would actually like to have an <code>Observable&lt;T&gt;</code>.</p>

<p>To accomplish this, we can use a flattening operator. We could use <code>switchMap</code> for example.</p>

<pre><code class="language-typescript">const work$ = ...
const trigger$ = ...

const workExecutedOnTrigger$: Observable&lt;T&gt; = trigger$.pipe(
	switchMap(triggerValue =&gt; work$)
);
</code></pre>

<p>And this is it! Now we have an observable <code>workExecutedOnTrigger$</code> that will execute our <code>work$</code> and will restart that every time our <code>trigger$</code> fires. It is restarted as the <code>switchMap</code> operator will do the following:</p>

<ol>
  <li>the <code>trigger$</code> fires a next event</li>
  <li>the <code>switchMap</code> operator takes that event and maps it to <code>work$</code></li>
  <li>the <code>switchMap</code> operator subscribes to that stream</li>
  <li>Every event emitted by the <code>work$</code> is being passed down</li>
  <li>if the <code>trigger$</code> fires a new event, the previous execution of <code>work$</code> is unsubscribed from</li>
  <li>Step 2 through 5 is repeated</li>
</ol>

<p>Thanks to the <code>switchMap</code> operator, we can restart the ‘inner’ <code>work$</code>. This means that we can <strong>restart our work</strong>.</p>

<p><strong>Note:</strong> To create the <code>trigger$</code> we can use a <code>Subject</code>. I’ll cover this in the next pattern ‘mapping function calls to streams’.</p>

<h2 id="when-to-use-it">When to use it</h2>

<p>As promised, here are some concrete example when you would use this:</p>

<ul>
  <li>In an autocomplete, we want to execute a backend call every time the user types something new. We want to restart the call to the backend.</li>
  <li>We fetch some data when the page loads for the first time. When we want to do this a second time (after data has been updated for example), we want to re-execute that call.</li>
</ul>

<pre><code class="language-typescript">this.data$ = this.load$.pipe(
   switchMap(_ =&gt; this.service.loadData())
);
</code></pre>
<p>In this example <code>load$</code> will emit at start up and every time the data needs to be loaded. This is a very common scenario where this concept of restarting work can be used.</p>

<h2 id="special-thanks">Special thanks</h2>

<p>Special thanks to <a href="https://twitter.com/elmd_" target="blank">Dominic Elm</a> for reviewing!</p>


	  ]]></description>
	</item>

	<item>
	  <title>Safe HTTP calls with RxJS</title>
	  <link>//safe-http-calls-with-rxjs/</link>
	  <author></author>
	  <pubDate>2018-10-24T00:00:00+00:00</pubDate>
	  <guid>//safe-http-calls-with-rxjs/</guid>
	  <description><![CDATA[
	     <p>Hi there, since it’s very busy lately this will probably be my one of my shortest articles ever.
Maybe that’s a good thing, because now you don’t have an excuse not to read it. It’s short, compact
and maybe you will learn a thing or two.</p>

<h2 id="the-problem">The problem</h2>

<p>The article is all about making sure our HTTP calls don’t die on bad connections, since strangely enough, <strong>404 responses can kill your application when using RxJS</strong>.</p>

<p>Remember that RxJS observables have 3 types of events right?</p>
<ul>
  <li><code>next</code>: passing in a new value into the observable</li>
  <li><code>error</code>: when an error occurs</li>
  <li><code>complete</code>: When the observable is completed</li>
</ul>

<p>We should not forget that <strong>an Error event will actually stop the observable</strong>. It will cease to exist.</p>

<p>You might say: “That’s not that bad, we’ll just create a new one every time we want to fetch data”.</p>

<p>When you are approaching your application the <em>reactive way</em>, this scenario might be problematic:
Imagine a typeahead search where we want to retrieve results for every input value. We have an observable of searchterms and we trigger the
HTTP request for every value using a <code>switchMap</code>.</p>

<pre><code class="language-typescript">// this observable contains the values
// of what the user is searching for
// over time
const searchTerm$: Observable&lt;string&gt;;

// when the term receives a new value...
// go fetch some data
const results$ = searchTerm$.pipe(
    switchMap(term =&gt; fetchData(term))
)

// subscribe to the observable to start listening
results$.subscribe((response: Result[]) =&gt; {
    console.log(response);
})
</code></pre>
<p>This all works fine, until an error happens in the observable. This could come from a bad connection, server down-time or anything that went wrong during the HTTP request (500, 404, …) 
If the user is having a bad connection which might result in a <code>404</code>, the observable will stop and the application will be broken. The user can search for results as much as he or she wants, the HTTP calls will never happen again.</p>

<h2 id="catcherror">catchError</h2>

<p>We could use the <code>catchError</code> operator that will basically catch the error for us, and return a brand new observable(containing the error).
That observable will have the error as a value, instead of throwing it again as an error.
That way we could actually show the user a decent message.
This might look something like this:</p>

<pre><code class="language-typescript">const results$ = searchTerm$.pipe(
    switchMap(term =&gt; 
        fetchData(term).pipe(
            // return an observable with the error inside
            catchError(e =&gt; of(e))
        )
    )
)
results$.subscribe(
    (response: Result[] | HttpErrorResponse) =&gt; {
        if(response instanceof HttpErrorResponse){
            console.log('oh no:(');
            return;
        }
        console.log('do something fancy');
    });
)
</code></pre>

<p>Ps: I’m not trying to say that this is the best idea to catch errors. I’m just showing you around some basics.</p>

<p>Do note that the <code>catchError</code> operator is applied to the result observable that <code>fetchData()</code> returns, and not added as the second operator of the first pipe. 
From the moment an observable receives an error, it will die… That’s why it’s important to catch the error on the inner observable.</p>

<h2 id="retrywhen">retryWhen</h2>

<p>Ok, great! The application won’t break anymore, but now imagine the following scenario: Our user is sitting in the train and drives through a tunnel. The connection is gone for a few seconds and the user won’t get results.</p>

<p>We could fix that by telling RxJS to retry a few times</p>

<pre><code class="language-typescript">const results$ = searchTerm$.pipe(
    switchMap(term =&gt; 
        fetchData(term).pipe(
            retryWhen(e$ =&gt; e$.pipe(
                // try again after 2 seconds
                delay(2000),
                // stop trying after 5 times
                take(4)
            )
            // still keep the observable alive if
            // the first 5 times fail
            catchError(e =&gt; of(e))
        )
    )
)
</code></pre>

<p>You can find more information about <code>retryWhen</code><a href="https://www.learnrxjs.io/operators/error_handling/retrywhen.html">here</a></p>

<h2 id="using-the-online-event">Using the online event</h2>

<p>Even though this is a good solution, there is room for improvement. A great choice is to use the <a href="https://developer.mozilla.org/en-US/docs/Web/API/NavigatorOnLine/Online_and_offline_events">online</a> event from HTML5 to tell the browser to retry when the user regains internet connection. It’s even shorter than before and it’s super elegant</p>

<pre><code class="language-typescript">const results$ = searchTerm$.pipe(
    switchMap(term =&gt; 
        fetchData(term).pipe(
            retryWhen(() =&gt; fromEvent(window, 'online'))
            // still keep the observable alive if
            // the server would return a different
            // HTTP error
            catchError(e =&gt; of(e))
        )
    )
)
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>RxJS gives us great control over HTTP calls! If we know how error handling works it becomes a breeze to take our HTTP calls to the next level.
This doesn’t only apply to typeahead searches but to every observable where we combine an existing stream with an error-affected one like HTTP. For instance: this can also happen in NgRx effects or with the angular router.</p>

<p>There, I told you it would be short, I hope you learned something though.</p>

<p>Also be sure to check this article: <a href="https://blog.angularindepth.com/power-of-rxjs-when-using-exponential-backoff-a4b8bde276b0">Power of RxJS when using exponential backoff</a></p>

<h2 id="special-thanks">Special thanks</h2>

<ul>
  <li><a href="https://twitter.com/AmarildoKurtaj">@AmarildoKurtaj</a> The last example was based on his idea</li>
</ul>

<p>Reviewers:</p>
<ul>
  <li><a href="https://twitter.com/fmalcher01">Ferdinand Malcher</a></li>
  <li><a href="https://twitter.com/FabianGosebrink">Fabian Gosebrink</a></li>
  <li><a href="https://twitter.com/tim_deschryver">Tim deschryver</a></li>
  <li><a href="https://twitter.com/webdave_de">David Müllerchen</a></li>
  <li><a href="https://twitter.com/rubenverm">Ruben Vermeulen</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Building a safe autocomplete operator in RxJS</title>
	  <link>//building-a-safe-autocomplete-operator-with-rxjs/</link>
	  <author></author>
	  <pubDate>2018-07-13T00:00:00+00:00</pubDate>
	  <guid>//building-a-safe-autocomplete-operator-with-rxjs/</guid>
	  <description><![CDATA[
	     <p>A well-known use case of RxJS is creating a simple autocomplete search in only a few lines of code.
This article is not just about creating our own autocomplete operator, we will create an autocomplete operator that is completely safe (we will cover the perception of safe later in this article).</p>

<p>When creating a standard autocomplete with RxJS we most likely implement a <code>debounceTime</code> operator to throttle the text that the user is typing into the autocomplete and we use a <code>switchMap</code> operator instead of a <code>mergeMap</code> operator to abort previous calls.</p>

<p>The implementation of this autocomplete might look like this:</p>

<pre><code class="language-typescript">const term$ = new BehaviorSubject('');
const results$ = term$
    .pipe(
        // wait until the user stops typing for a second
        debounceTime(1000),
        // higher order observable, abort previous
        // call if still busy
        switchMap(term =&gt; getAutocompleteSuggestions(term))
    )
</code></pre>

<h2 id="the-problem">The problem</h2>

<p>When the user stops typing for 1 second, the browser will create a new XHR call. From that moment on, when the user types again and a previous XHR call is still busy, the browser will abort that XHR call to avoid racing conditions, and create a new XHR call. This is due to the <code>switchMap</code> operator since it will unsubscribe from the previous observable.</p>

<p>Although that’s great, there is one problem though. What if the user starts typing again when an XHR call is still busy? 
Since we have implemented a <code>debounceTime</code> operator, the call will not be aborted until one second has passed.
In that period of time new results might be returned and showed to the user, which might not be what we want since <strong>they are not relevant anymore</strong>.</p>

<p>What we want is that the XHR call gets aborted from the moment the user starts typing again, we don’t want to wait for a second.
This sounds like an ideal scenario to write our custom operator.
But, before creating our own operator, let’s just combine some operators to get the job done.</p>

<p>A possible solution for this problem is using a <code>takeUntil</code> operator on the observable that will trigger the XHR call.
The <code>takeUntil</code> operator will complete the observable as soon as it gets a value. We want to complete (and therefore abort) the observable when the user types again. With that knowledge we can write something like this:</p>

<pre><code class="language-typescript">const term$ = new BehaviorSubject('');
const results$ = term$
    .pipe(
        debounceTime(1000),
        switchMap(term =&gt; 
            getAutocompleteSuggestions(term)
                .pipe(
                    takeUntil(term$) // this still won't work
                )
            )
        )
    )
</code></pre>

<p>Sadly, this does not work yet.</p>

<p>Our <code>term$</code> observable is a <code>BehaviorSubject</code> for two reasons:</p>
<ul>
  <li>We want to pass an initial value to the subject</li>
  <li>A <code>BehaviorSubject</code> is a <code>ReplaySubject(1)</code> behind the scenes that keeps track of the last value. This is important if we want to subscribe to that observable in a later stage (which is kinda what we do with the <code>takeUntil</code> operator).</li>
</ul>

<p>Because the <code>term$</code> observable is keeping track of the last value, the <code>takeUntil</code> operator will always have a value, resulting in the fact that every XHR call gets aborted immediately. This is not what we want.
We want to skip one value of the <code>term$</code> observable every time.
We can achieve that with the <code>skip</code> operator as shown in the following example:</p>

<pre><code class="language-typescript">const term$ = new BehaviorSubject('');
const results$ = term$
    .pipe(
        debounceTime(1000),
        switchMap(term =&gt; 
            getAutocompleteSuggestions(term)
                .pipe(
                    takeUntil(
                        //skip 1 value
                        term$.pipe(skip(1))
                    )
                        
                )
            )
        )
    )
</code></pre>

<p>Now the following scenario works:</p>
<ul>
  <li>User types ‘l’</li>
  <li>Application waits for a second</li>
  <li>Application creates an XHR call</li>
  <li>User types ‘lu’</li>
  <li>Even though the XHR call wasn’t finished yet it gets aborted immediately (it doesn’t wait for a second anymore to abort that XHR call)</li>
</ul>

<p>Because of that the user never gets irrelevant data on its screen.</p>

<h2 id="extracting-the-logic-into-a-custom-operator">Extracting the logic into a custom operator</h2>

<p>We don’t want to write this logic every time, so let’s extract this logic into a custom written operator.</p>

<p>Turns out that creating custom operators is super easy. An operator is just a function that returns a function that gets the source observable.</p>

<pre><code class="language-typescript">const autocomplete = (/* additional parameters */) =&gt; 
    (source$) =&gt; source$.pipe(/* do stuff */ )
</code></pre>

<p>We can pass the <code>time</code> and <code>selector</code> function as parameters and use the operators we have written to create our own custom operator.
The operator looks like this:</p>

<pre><code class="language-typescript">const autocomplete = (time, selector) =&gt; (source$) =&gt;
  source$.pipe(
    debounceTime(time),
    switchMap((...args: any[]) =&gt; selector(...args)
        .pipe(
            takeUntil(
                source$
                    .pipe(
                        skip(1)
                    )
            )
        )
    )
  )
</code></pre>

<p>Using our operator is super easy:</p>

<pre><code class="language-typescript">const term$ = new BehaviorSubject('');
const results$ = term$
    .pipe(
        autocomplete(1000, term =&gt; getAutocompleteSuggestions(term))
    )
</code></pre>

<p>You can find the sourcecode on stackblitz.</p>
<iframe src="https://stackblitz.com/edit/safe-switchmap?embed=1&amp;file=src/app/app.component.ts" style="width: 100%; height: 500px"></iframe>

<h2 id="conclusion">Conclusion</h2>

<p>The combination of <code>debounceTime</code> and <code>switchMap</code> don’t always cover everything. Showing irrelevant data to our users might not be what we want and creating our own operators is super easy! I hope you enjoyed the article.</p>

<h2 id="special-thanks">Special thanks</h2>

<p>A special thanks for the awesome reviewers:</p>

<ul>
  <li>Nicholas Jamieson <a href="https://twitter.com/ncjamieson">@ncjamieson</a></li>
  <li>Philippe Martin <a href="https://twitter.com/feloy2">@feloy2</a></li>
  <li>Jan-Niklas Wortmann <a href="https://twitter.com/niklas_wortmann">@niklas_wortmann</a></li>
  <li>Maarten Tibau <a href="https://twitter.com/maartentibau">@maartentibau</a></li>
  <li>Kwinten Pisman <a href="https://twitter.com/kwintenp">@kwintenp</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Thinking reactive with the SIP principle</title>
	  <link>//the-sip-principle/</link>
	  <author></author>
	  <pubDate>2018-06-30T00:00:00+00:00</pubDate>
	  <guid>//the-sip-principle/</guid>
	  <description><![CDATA[
	     <p>A few months back we released <a href="https://blog.strongbrew.io/rxjs-best-practices-in-angular/">RxJS best practices in Angular</a> and a while before that <a href="https://blog.strongbrew.io/thinking-reactively-in-angular-and-rxjs/">Thinking reactively in Angular and RxJS</a>. 
Both of these articles are focussing on “trying to make the mind switch towards reactive programming”.</p>

<p>However, sometimes we like to have structured opinionated ways of tackling problems, especially when things become complex. We like a roadmap of some kind, something to fall back on, something to guide us through these complex reactive scenarios.</p>

<p>While writing RxJS code for small pragmatic solutions can be super easy, it might become complex when combining multiple streams or doing other advanced stuff.</p>

<p>We as StrongBrew are huge fans of reactive programming and we use our reactive mindset in Angular on a daily basis.
In this article we will learn a principle that helps us to tackle very complex RxJS situations in an opinionated structured way.</p>

<p>The code of this article is written with <a href="https://angular.io">Angular</a> but the concepts can be used with every framework.</p>

<h2 id="the-situation">The situation</h2>

<p>We are going to build an application to search for starships in the <a href="https://swapi.co">swapi api</a>. The application counts a few features:</p>
<ul>
  <li>It has to load data on page load</li>
  <li>The user can search for starships by entering text in the searchbox</li>
  <li>The user can load starships by a chosen model</li>
  <li>The user can load starships by a random model</li>
  <li>There is a loading indicator that needs to be shown when the data is being loaded</li>
  <li>Previous XHR calls should be canceled to avoid race conditions</li>
  <li>We want to filter the results by the number of passengers allowed on the ship. <strong>Note: This is a clientside filter</strong></li>
</ul>

<p>As we can see, there is quite a lot of asynchronous logic going on here, and if we would implement this in an imperative way, it would be pretty hard to keep it simple. However, the application can easily be written with the use of RxJS. In this application we don’t want to think in actions anymore, we want to think in streams of data. <strong>Everything is a stream!</strong></p>

<h2 id="the-sip-principle">The SIP principle</h2>
<p>With StrongBrew, we came up with a simple principle of handling this reactive mindset. We call it the <strong>SIP principle</strong>.
The SIP principle stands for the following:</p>
<ul>
  <li>S: Source streams</li>
  <li>I: Intermediate streams</li>
  <li>P: Presentation streams</li>
</ul>

<h3 id="source-streams">Source streams</h3>

<p>These streams will contain all the user interaction. They are generally bound to the outputs of our dumb components. A source stream could also contain real-time data, but we won’t cover that part in this article.
Let’s have a look at our application and look for the source streams there:
(the left column pretty much contains all the user interaction)
<img src="/assets/images/posts/sip-principle/source-streams.png" alt="Source streams" /></p>

<p>After executing the first step of the SIP principle we have found 4 source streams.
<code>searchTerm$</code>, <code>selectedModel$</code>, <code>randomModel$</code> and <code>numberOfPassengers$</code>.</p>

<p>What’s important to note here is that we named these streams as <strong>streams of data</strong> rather than naming them as streams of actions. We want to stop thinking in actions and start thinking in streams of data, remember? That’s why we didn’t name the first stream <code>search$</code> (which would be an action), we rather named it <code>searchTerm$</code> so we know it contains a search term.</p>

<p>Source streams are <strong>mostly subjects</strong> or streams that come from the framework, e.g. a routing params stream.</p>

<p>In our application the source streams will look like this:</p>

<pre><code class="language-typescript">searchTerm$ = new ReplaySubject&lt;string&gt;(1);
selectedModel$ = new ReplaySubject&lt;string&gt;(1);
randomModel$ = new ReplaySubject&lt;string&gt;(1);
// needs an initial value
numberOfPassengers$ = new BehaviorSubject(1000000); 
</code></pre>

<p>These subjects will be populated by the outputs as shown below:</p>

<pre><code class="language-html">&lt;sidebar 
    (search)="searchTerm$.next($event)"
    (selectModel)="selectedModel$.next($event)"
    (randomModel)="randomModel$.next($event)"
    (changeNumberOfPassengers)="numberOfPassengers$.next($event)"
&gt;
&lt;/sidebar&gt;
...
</code></pre>

<h3 id="presentation-streams">Presentation streams</h3>

<p>After finding the source streams we need to find the presentation streams.
These are the streams that our template needs to render properly. These are quite easy to find. We just have to look at the template and see which inputs our components expect. We can have a look at our template. (The outputs are stripped for readability purposes).</p>

<pre><code class="language-html">  &lt;sidebar class="sidebar" 
    [models]="fixedModels" 
    [numberOfPassengers]=""
  &gt;
  &lt;/sidebar&gt;
  &lt;div class="main"&gt;
    &lt;starship-list 
        [starships]=""
        [loading]=""&gt;
    &lt;/starship-list&gt;
  &lt;/div&gt;
</code></pre>

<p>We can instantly see that we need 3 presentation streams:
We need the number of passengers, the starships that need to be shown and whether the application is loading or not. Let’s fill in the blanks, shall we?!</p>

<pre><code class="language-html">  &lt;sidebar class="sidebar" 
    [models]="fixedModels" 
    [numberOfPassengers]="numberOfPassengers$|async"
  &gt;
  &lt;/sidebar&gt;
  &lt;div class="main"&gt;
    &lt;starship-list 
        [starships]="filteredResults$|async"
        [loading]="loading$|async"&gt;
    &lt;/starship-list&gt;
  &lt;/div&gt;
</code></pre>

<p>So after step 2 we have found the following presentation streams: <code>numberOfPassengers$</code>, <code>filteredResults$</code> and <code>loading$</code>.</p>

<h3 id="starting-with-the-sip-diagram">Starting with the SIP diagram</h3>

<p>Let’s visualize these streams by creating a SIP diagram:</p>

<p><img src="/assets/images/posts/sip-principle/sp.png" alt="Source streams, presentation streams" /></p>

<p>The goal is to calculate the presentation streams, based on the source streams. There are 2 presentation streams that we need to calculate: <code>filteredResults$</code> and <code>loading$</code>. We don’t need to calculate <code>numberOfPassengers$</code> since it’s the same stream as the source stream.</p>

<p>Let’s start with the <code>filteredResults$</code>. The <code>filteredResults$</code> is dependent on <code>searchTerm$</code>, <code>selectedModel$</code>, <code>randomModel$</code> and <code>numberOfPassengers$</code>. To make this calculation easier we can use intermediate streams.</p>

<h3 id="intermediate-streams">Intermediate streams</h3>

<p>Intermediate streams are streams that are used to make the bridge between the source streams and presentation streams easier.
Let’s create a <code>query$</code> stream and a <code>results$</code> stream to make the calculation easier.</p>

<p><img src="/assets/images/posts/sip-principle/sip1.png" alt="SIP 1" /></p>

<p>We will use custom marble diagrams to visualize the different parts of the SIP diagram throughout this article.</p>

<h4 id="calculating-the-query">Calculating the query$</h4>

<p>The first intermediate stream that we have to create is the <code>query$</code> which is simply a merge from the <code>searchTerm$</code>, <code>selectedModel$</code> and <code>randomModel$</code>.</p>

<p><img src="/assets/images/posts/sip-principle/query.png" alt="Query" /></p>

<p>As we can see these 3 streams are being merged into one new <code>query$</code>. We don’t have to worry about when a user searches or selects a model, or even requests a random model. We only care about that simple stream of data, the <code>query$</code>.</p>

<h4 id="calculating-the-results">Calculating the results$</h4>

<p>Every time the <code>query$</code> gets a new value we want to fetch data from the API. For that we will use the <code>switchMap</code> operator.</p>

<p><img src="/assets/images/posts/sip-principle/results.png" alt="Results" /></p>

<h4 id="calculating-filteredresults">Calculating filteredResults$</h4>

<p>We are ready to finish up the <code>filteredResults$</code> stream.
If we look back at the previous SIP diagram we can see that we can create that stream by combining the <code>results$</code> and the <code>numberOfPassengers$</code>.</p>

<p><img src="/assets/images/posts/sip-principle/filteredResults.png" alt="Filtered results" /></p>

<h4 id="the-loading">The loading$</h4>

<p>The next presentation stream that we want to create is called the <code>loading$</code>. Let’s update the SIP diagram accordingly. The <code>loading$</code> is based on the <code>query$</code> and the <code>results$</code>.</p>

<p><img src="/assets/images/posts/sip-principle/sip2.png" alt="sip 2" /></p>

<p>Every time the <code>query$</code> gets a new value the <code>loading$</code> should get the value <code>true</code>. Everytime the <code>result$</code> gets a new value the <code>loading$</code> should get the value <code>false</code>.
So if we map every value of the <code>query$</code> to <code>true</code> and if we map every value of the <code>results$</code> to <code>false</code>, and merge those 2, we have created our <code>loading$</code> stream.</p>

<p>Let’s create one last marble diagram for that.
<img src="/assets/images/posts/sip-principle/loading.png" alt="Loading" /></p>

<h3 id="what-do-we-need-to-share">What do we need to share?</h3>

<p>We have came a long way, we have created the complete SIP diagram. We have visualized all the streams by creating marble diagrams, but if we look closely at the SIP diagram we might notice a problem.
There are 2 arrows leaving the <code>query$</code> and 2 arrows leaving the <code>results$</code>. Every arrow stands for a subscription on the observable where the arrow starts.
When working with cold observables, the producer function for that observable is executed every time we subscribe. Since <code>query$</code> is a hot stream, it doesn’t really matter, but <code>results$</code> will trigger an HTTP call every time it gets subscribed to. In short: the subscription on <code>loading$</code> and <code>filteredResults$</code> will trigger a subscription on <code>results$</code> twice. The SIP diagram show us which subscriptions need to be shared.</p>

<p><img src="/assets/images/posts/sip-principle/sip3.png" alt="sip3" /></p>

<h2 id="check-it-out">Check it out</h2>

<p>The SIP diagram is complete now and we can start coding. Since this article is really about the SIP principle I won’t explain the code in detail. However, you can find the complete code in the StackBlitz below.</p>
<iframe src="https://stackblitz.com/edit/sip-principle?embed=1&amp;file=app/app.component.ts" style="width: 100%; height: 500px"></iframe>

<h2 id="conclusion">Conclusion</h2>

<p>Before starting with implementing complex RxJS screens. Take a whiteboard and draw the flow first. The SIP principle that we created works for us but isn’t the only way to go of course.</p>

<p>If you check the code inside the StackBlitz, you might be surprised about the amount of lines of code that we need to create this application. We have only a few lines of real logic, and we have covered most corner cases by thinking reactive.</p>

<p>Because of the use of the <code>async</code> pipe we don’t need to unsubscribe from any stream manually since the <code>async</code> pipe does that for us.</p>

<h2 id="special-thanks">Special thanks</h2>

<p><a href="https://twitter.com/jvandemo">Jurgen van de Moere</a> for helping us with finding the right acronym.</p>

<p>And the awesome reviewers:</p>
<ul>
  <li><a href="https://twitter.com/manfredsteyer">Manfred Steyer</a></li>
  <li><a href="https://twitter.com/niklas_wortmann">Jan-Niklas Wortmann</a></li>
  <li><a href="https://twitter.com/tim_deschryver">Tim Deschryver</a></li>
  <li><a href="https://twitter.com/webdave_de">David Müllerchen</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>A glitch in combineLatest (and how to fix it!)</title>
	  <link>//combine-latest-glitch/</link>
	  <author></author>
	  <pubDate>2018-06-12T00:00:00+00:00</pubDate>
	  <guid>//combine-latest-glitch/</guid>
	  <description><![CDATA[
	     <p>The <code>combineLatest</code> operator is probably one of my favorite ones, that I believe everyone should know. You should never try to learn all of them but <code>combineLatest</code>, to me, is definitely one of those ~15 you should probably understand.</p>

<p><strong>Note:</strong> If you are unfamiliar with this operator, I suggest you check it out immediately <a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-combineLatest" target="_blank">here</a> or <a href="http://reactive.how/combinelatest" target="_blank">here</a>.</p>

<p>Even though it is one of the most well known operators, it can potentially introduce some weird behaviour. Let’s try and find the weird behaviour and see how we can fix it.</p>

<h2 id="identifying-the-problem">Identifying the problem</h2>

<p>To do so, I created an application that visualizes a number of pokemon based on a limit and offset parameter.</p>

<p><img src="https://www.dropbox.com/s/u1autxtkhlp3nfk/Screenshot%202018-06-09%2013.44.16.png?raw=1" alt="example-app-screenshot" /></p>

<p>Every time the limit <strong>or</strong> the offset changes, a backend call is triggered that will update the list of pokemon to be shown.</p>

<p>Let’s take a look at how we can set up our stream to make this work. We will start by looking at the marble diagram.</p>

<p><img src="https://vectr.com/tmp/f1jfpxhCHV/b8pN04Jr9.svg?width=1000&amp;height=461.54&amp;select=b8pN04Jr9page0" alt="marble-diagram" /></p>

<p>We have a stream of the limit values and one for the offset values. We combine these streams using <strong><code>combineLatest</code> to create a stream that will have a new value every time one of the source streams changes</strong>. We then use <code>switchMap</code> to fetch the data from the backend based on these values to get a <code>pokemon$</code>. Because we use <code>switchMap</code>, if a call is not finished yet, it will be cancelled when a new call is initiated by changing the limit or offset.</p>

<p>Code wise this looks like this:</p>

<pre><code class="language-typescript">this.pokemon$ = combineLatest(limit$, offset$)
       .pipe(
        map(data =&gt; ({limit: data[0], offset: data[1]})),
        switchMap(data =&gt; this.pokemonService.getPokemon(data.limit, data.offset)),
        map((response: {results: Pokemon[]}) =&gt; response.results),
      );
</code></pre>

<p>Here is the live example you can play with:</p>

<iframe style="width: 100%; height: 450px" src="https://stackblitz.com/edit/angular-deqtkx?embed=1&amp;file=src/app/app.component.ts"></iframe>

<p><strong>Note:</strong> If you open Chrome’s DevTools, head over to the ‘Network’ tab and update the values pretty quick, you can see the calls being cancelled.</p>

<h3 id="i-thought-their-was-some-weird-behavior">I thought their was some weird behavior?</h3>

<p>Everything seems to work fine right? So where is the hiccup?
Aside from the option to change the limit and offset values, there is also a ‘reset’ button. This button will set the values back to 5 and 0.</p>

<pre><code class="language-typescript">reset() {
    this.limitControl.setValue(5);
    this.offsetControl.setValue(0);
}
</code></pre>

<p>To see the hiccup, open Chrome’s DevTools, open the ‘Network’ tab and check what happens when you click the button.</p>

<p><img src="https://www.dropbox.com/s/dxcct5dld4wf0c3/combine-latest-glitch.gif?raw=1" alt="gif-reset-clicked" /></p>

<p>Whenever the button is clicked, we can see that a call is initiated but immediately cancelled and a new call is started. That’s a little strange no?</p>

<h3 id="explaining-the-behavior">Explaining the behavior</h3>

<p>Actually, this makes sense. In the description of the marble diagram above, there was a highlight:</p>

<blockquote>
  <p>‘<code>combineLatest</code> creates a stream that will have a new value every time one of the source streams changes’.</p>
</blockquote>

<p>By clicking the reset button, we updated both of our source streams by resetting both the limit and offset value at the same time. The effect of this action was that the stream created by <code>combineLatest</code> fired twice, thus starting two backend requests, thus, cancelling one immediately because we used <code>switchMap</code>.</p>

<p>To make it even more clear, lets put it in steps.</p>

<ul>
  <li><code>combineLatest</code> holds the last values from all source streams (in the gif, the begin scenario was, limit = 8, offset = 2)</li>
  <li>the reset button is clicked</li>
  <li>limit is set to 5</li>
  <li><code>combineLatest</code> sees a new value coming in for limit and emits a new combination, limit = 5, offset = 2</li>
  <li><code>switchMap</code> gets these values and subscribes to the stream that triggers a backend call</li>
  <li>offset is set to 0</li>
  <li><code>combineLatest</code> sees a new value coming in for offset and emits a new combination, limit = 5, offset = 0</li>
  <li><code>switchMap</code> gets these values, unsubscribes (and thus cancels) the previous request and starts a new one</li>
</ul>

<p>Something you might have not expected in this flow is that, whenever the limit is set, this change propagates to <code>combineLatest</code> directly before changing the offset.</p>

<p><strong>Note:</strong> This is possible because RxJS does not have the notion of transactions. In a ‘true’ Functional Reactive Programming implementation, this would not be possible. Transactions would make sure there can be no simultaneous events. This is food for another post though :).</p>

<h3 id="how-can-we-fix-this">How can we fix this?</h3>

<p>If there was a way we could make sure that changes that happen in the same call stack (which is what is happening when clicking the reset button), are discarded in favor of the last change, we could fix our problem.</p>

<p>This means, that when <code>combineLatest</code> emits two values in the same call stack, the last one is send through when the call stack is cleared.</p>

<p>To do this, we can leverage <code>debounceTime</code> with a value of 0 directly after the <code>combineLatest</code>. This will make sure only the last value is passed through to the <code>switchMap</code> and this after the call stack has been cleared.</p>

<p><strong>Note:</strong> If you do not know what the call stack is, watch one of my favorite talks ever by Philip Roberts that covers it <a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" target="_blank">here</a>.
<strong>Note2:</strong> Whenever there is a mention of ‘in the same call stack’ this could be replaced with ‘changes that occur during the same turn of the event loop’.</p>

<p>Let’s put this in steps again to make it clear.</p>

<ul>
  <li><code>combineLatest</code> holds the last values from all source streams (in the gif, the begin scenario was, limit = 8, offset = 2)</li>
  <li>the reset button is clicked</li>
  <li>limit is set to 5</li>
  <li>the <code>combineLatest</code> operator sees a new value coming in for limit and emits a new combination, limit = 5, offset = 2</li>
  <li>the <code>debounceTime</code> operator sees a new value and (because of the 0) will wait until the call stack is cleared to pass it on</li>
  <li>offset is set to 0</li>
  <li>the <code>combineLatest</code> operator sees a new value coming in for offset and emits a new combination, limit = 5, offset = 0</li>
  <li>the <code>debounceTime</code> operator sees again a new value, will discard of the old one, and will wait for the stack to be cleared to pass it on</li>
  <li>the call stack is cleared</li>
  <li>the <code>debounceTime</code> operator sees no new value is given and will pass the combination, limit = 5, offset = 0, on</li>
  <li>the <code>switchMap</code> operator gets these values and subscribes to the stream that triggers a backend call</li>
</ul>

<p>The updated code looks like this:</p>

<pre><code class="language-typescript">this.pokemon$ = combineLatest(limit$, offset$)
       .pipe(
        map(data =&gt; ({limit: data[0], offset: data[1]})),
        debounceTime(0),
        switchMap(data =&gt; this.pokemonService.getPokemon(data.limit, data.offset)),
        map((response: {results: Pokemon[]}) =&gt; response.results),
      );
</code></pre>

<p>You can play with the updated example here and see that the issue no longer happens.</p>

<iframe style="width: 100%; height: 450px" src="https://stackblitz.com/edit/angular-gnlpt6?embed=1&amp;file=src/app/app.component.ts"></iframe>

<h2 id="conclusion">Conclusion</h2>

<p>When combining streams with the <code>combineLatest</code> operator, where the source streams might have new values within the same call stack, you might get unexpected behavior. You can fix this by adding a <code>debounceTime(0)</code> right after the <code>combineLatest</code>.</p>

<p><strong>Note:</strong> Special thanks to <a href="https://twitter.com/elmd_" target="_blank">Dominic Elm</a>, <a href="https://twitter.com/ncjamieson" target="_blank">Nicholas Jamieson</a>, <a href="https://twitter.com/chaos_monster" target="_blank">Martin Sonnenholzer</a>, <a href="https://twitter.com/maartentibau" target="_blank">Maarten Tibau</a> and <a href="https://twitter.com/frederikprijck" target="_blank">Frederik Prijck</a> for reviewing!</p>


	  ]]></description>
	</item>

	<item>
	  <title>Be careful when using shareReplay</title>
	  <link>//share-replay-issue/</link>
	  <author></author>
	  <pubDate>2018-04-23T00:00:00+00:00</pubDate>
	  <guid>//share-replay-issue/</guid>
	  <description><![CDATA[
	     <p>This post describes an issue with the current <code>shareReplay</code> operator in RxJS. There has been an open issue for this on Github, but as it has been open for quite some time now. The issue might introduce some memory leaks, so I decided to write about it.</p>

<p>You can find the Github issue <a href="https://github.com/ReactiveX/rxjs/issues/3336" target="_blank">here</a>. There is already a PR for this issue that has been discussed <a href="https://github.com/ReactiveX/rxjs/pull/3354" target="_blank">here</a>. However, it is still unclear what the desired behavior should be. This needs to be discussed by the core team members.</p>

<p>Hopefully this will get resolved and it will get fixed really quick :). For the time being, it made sense to warn people about it.</p>

<h2 id="lets-identify-the-issue">Let’s identify the issue</h2>

<p>Let’s take a look at the following code.</p>

<pre><code class="language-typescript">const interval$ = interval(1000)
  .pipe(
     tap(console.log),
     mapTo('nextValue'),
     take(10),
     shareReplay(1),
  );
</code></pre>

<p>We are defining an interval stream. Let’s assume that we need this interval stream to create multiple other streams. In that case, we need to transform our stream from a cold stream to a hot one by multicasting it. If we do not do this we are basically subscribing multiple times to the interval stream, and we are triggering the interval multiple times.</p>

<p>Using the <code>shareReplay</code> operator, we are multicasting our <code>interval$</code>. So far so good right?!</p>

<p>Let’s subscribe to this stream and stop subscribing after ‘3000ms’.</p>

<pre><code class="language-typescript">const subscription = interval$.subscribe(console.log);

setTimeout(() =&gt; {
  subscription.unsubscribe();
}, 3000);
</code></pre>
<p><code>shareReplay</code> uses a <code>refCount</code> under the hood. This will make sure that the source stream is subscribed to when the subscribers count goes up to 1 or higher. Whenever we unsubscribe, the <code>refCount</code> of the subscription is dropping to 0. In that case, we expect that the source stream (being our interval) is cleaned up and it stops emitting values.</p>

<p>Let’s see what happens. A live example of the code can be found here:</p>

<p><a class="jsbin-embed" href="http://jsbin.com/kocagizoje/embed?js,console">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?4.1.4"></script></p>

<p>As you can see, the interval part of our stream keeps emitting whenever we unsubscribe. This might lead to some unexpected behavior in our code, or even memory leaks. Whenever the <code>interval$</code> has no more subscribers, it doesn’t make sense to keep the source subscription active.</p>

<h3 id="defining-the-problem">Defining the problem</h3>

<p>Whenever we are using the <code>shareReplay</code> operator, we must be very careful. The <code>shareReplay</code> operator does not clean up streams when they have not yet completed. In our case, the <code>interval$</code> keeps emitting values after we stopped listening. This will introduce a memory leak into our application.</p>

<h3 id="fixing-the-problem">Fixing the problem</h3>

<p>Whenever the stream we are multicasting will have multiple values, or even don’t complete on their own, it might be better to use the combination <code>publishReplay(1).refCount()</code> for the time being.</p>


	  ]]></description>
	</item>

	<item>
	  <title>RxJS polling strategies</title>
	  <link>//rxjs-polling/</link>
	  <author></author>
	  <pubDate>2018-04-19T00:00:00+00:00</pubDate>
	  <guid>//rxjs-polling/</guid>
	  <description><![CDATA[
	     <p>Polling is a common scenario in a lot of Single Page Applications. We want our user to see the latest data without them taking any actions. In some scenarios, we might even want to display this data real time. In most cases however, this is overkill and requires changes at the backend of our application. Polling is a really good ‘near immediate’ alternative.</p>

<p>Polling is something where RxJS really shines. We will look at different polling strategies and how we can implement them.</p>

<p><strong>Note:</strong> The examples in this post will use Angular but the concepts can be ported everywhere.</p>

<ul>
  <li><a href="#simple-polling">Simple polling</a></li>
  <li><a href="#polling-and-refresh-button">Combining polling with refresh button</a></li>
  <li><a href="#polling-and-reset">Polling and reset</a></li>
  <li><a href="#polling-when-data-is-resolved">Polling when data is resolved</a></li>
</ul>

<h3 id="simple-polling">Simple polling</h3>

<p>First we will take a look at a simple example where we want to fetch new data every 5 seconds. Let’s first try and think about what we need.</p>

<ul>
  <li>a backend call</li>
  <li>a trigger that tells us when we need to execute our backend call</li>
</ul>

<h4 id="backend-call">Backend call</h4>

<p>Executing a backend call is easy. We can create a stream that will execute a backend call when subscribed to like this.</p>

<pre><code class="language-typescript">const bitcoin$ = this.http.get('https://blockchain.info/ticker');
</code></pre>

<h4 id="trigger">Trigger</h4>

<p>Next thing we need is a trigger that will tell us when it is time to fetch our data. In a world without RxJS we would probably use <code>setInterval</code>. This function allows us to pass it a callback that gets executed every ‘x’ seconds.
With RxJS however, we have to change the way we think. We can no longer think in terms of callbacks, we have to think in terms of streams. If we apply this to the trigger we need, we want a stream that fires every ‘x’ seconds. 
Drawn in a ASCII marble diagram, this is what we want:</p>

<pre><code>----1----2----3----4----5...
</code></pre>

<p>RxJS has a static <code>interval</code> function that will create this streams for us. We can pass it a number which will denote the time between the events.</p>

<pre><code class="language-typescript">const trigger$ = interval(1000);
</code></pre>

<p>This is not enough however. Our trigger stream should also trigger at start time. Otherwise, we would only fetch data after ‘1000ms’ (with the example above).</p>

<p>RxJS provides another static function, ‘timer’, that will help us to create the following stream:</p>

<pre><code>0----1----2----3----4----5...
</code></pre>

<p>Code wise, this looks like this:</p>

<pre><code class="language-typescript">const trigger$ = timer(0, 1000);
</code></pre>

<h4 id="combine-to-polling-stream">Combine to polling stream</h4>

<p>Now we have the two streams that we need, it is time to combine them. If we think about it, we basically want to re-execute our <code>bitcoin$</code> to refetch the data, every time our <code>trigger$</code> fires. We want to map our trigger value to another observable/async action. To do that, we need to use a flattening operator. As flattening operators are not part of this post, you can read more about them <a href="https://blog.angularindepth.com/switchmap-bugs-b6de69155524" target="_blank">here</a>.</p>

<p>In our case, we are going to use the <code>concatMap</code> operator. This operator will execute all the <code>bitcoin$</code> without cancelling them. Let’s take a look at the code:</p>

<pre><code class="language-typescript">this.polledBitcoin$ = timer(0, 1000).pipe(
        concatMap(_ =&gt; bitcoin$),
        map((response: {EUR: {last: number}}) =&gt; response.EUR.last),
      );
</code></pre>
<p>We create a new stream, <code>this.polledBitcoin$</code> by mapping every event that the <code>trigger$</code> emits to our <code>bitcoin$</code>. The <code>concatMap</code> operator will subscribe to the <code>bitcoin$</code> internally and emit the result of that stream as events on the <code>polledBitcoin$</code>.</p>

<p>When we draw this out into a ASCII marble diagram, it looks like this:</p>

<pre><code>bitcoin:            -(b|)
trigger$:           0------1------2------3------4------5...
                    \      \      \      \      \      \
                     -(b|)  -(b|)  -(b|)  -(b|)  -(b|)  -(b|)
 
 
polledBitcoin$     ----b------b------b------b------b------b 
</code></pre>

<p>We have our <code>bitcoin$</code> that will, when subscribed to, take some time, and then emit the event and complete.</p>

<p>We have our <code>trigger$</code> where we map the values to the <code>bitcoin$</code>. The <code>concatMap</code> operator flattens the result and we get our <code>polledBitcoin$</code>. A stream that will fetch the value of bitcoin every second.</p>

<p>The live example can be found here:</p>

<iframe style="width: 100%; height: 500px" src="https://stackblitz.com/edit/angular-abcqen?embed=1&amp;file=app/app.component.ts"></iframe>

<p><strong>Note:</strong> You can open the devtools on the network tab to see the network requests. There are other Stackblitz demos in this post so you might want to open it in Stackblitz to be sure that the network tab only shows requests from a single demo.</p>

<h3 id="polling-and-refresh-button">Polling and refresh button</h3>

<p>Sometimes, users can be pretty impatient and want to have the control to fetch the data. We can accomplish this by adding a button that, when clicked, will fetch the data as well. But we want also want to keep our polling.</p>

<p>Let’s first try to think reactive on how we can accomplish this. We already have a stream that polls the data. We can create a stream that fetches the data whenever the button is clicked. When we have both of these streams, we can actually just combine them using the <code>merge</code> operator to get one stream that is both triggered by the polling and the button click.</p>

<p>We can simply add a button to our example and a click listener. When the button is clicked, we need to convert this click into a stream, since we will need a stream to ‘start with’. For this we can leverage a <code>Subject</code>.</p>

<pre><code class="language-typescript">manualRefresh = new Subject();

refreshDataClick() {
    this.manualRefresh.next('');
}
</code></pre>

<p>Now that we have a stream that is fired every time the button is clicked, we can simply use the same way of working that we had before. But now, our ‘source’ stream is not a <code>timer</code> but a <code>subject</code>.</p>

<pre><code class="language-typescript">this.manualRefresh
	.pipe(
       concatMap(_ =&gt; bitcoin$),
   );
</code></pre>

<p>Next thing we need to do is combine both of our streams that can trigger a backend call (and remove the double <code>concatMap</code> operator).</p>

<pre><code class="language-typescript">this.polledBitcoin$ = timer(0, 10000).pipe(
        merge(this.manualRefresh),
        concatMap(_ =&gt; bitcoin$),
        map((response: {EUR: {last: number}}) =&gt; response.EUR.last),
      );
</code></pre>

<p>That’s it. Now whenever the button is clicked or the timer triggers, a backend call will be done.</p>

<p>The live code example can be found here:</p>

<iframe src="https://stackblitz.com/edit/angular-zytccc?embed=1&amp;file=app/app.component.ts" style="height: 500px; width:100%"></iframe>

<h3 id="polling-and-reset">Polling and reset</h3>

<p>The previous polling strategy can introduce some unnecessary backend calls. Let’s think about the following scenario. Our timer stream triggers every 10s. After the app has started and has been running for 19s, the user clicks the button, triggering a backend call. And after 20s our timer stream fires as well, also triggering a backend call. This means that at both the 19th and the 20th second, we are fetching the data. This might be a little overkill.</p>

<p>Let’s think about how we can fix this. We already have a stream that will fetch the data immediately and then again and again with 10s in between. And actually, that’s all we need. When we have this stream, and the user clicks the button, we can just restart this stream. Since, when we restart this stream, we are fetching the data immediately (which is what we want when the user clicks), and again after 10 seconds. The ASCII marble diagram looks like this:</p>

<pre><code>bitcoin:            -(b|)
user clicks:                            C 
trigger$:           0------1------2-----!0------1------2-----|
                    \      \      \      \      \      \      
                     -(b|)  -(b|)  -(b|)  -(b|)  -(b|)  -(b|)
 
 
polledBitcoin$     ----b------b------b------b------b------b-- 
</code></pre>

<p><strong>Note:</strong> In ASCII marble diagrams, the ‘!’ means that the stream is unsubscribed from.</p>

<p>In the marble diagram above, ‘C’ denotes the user click. In that case, we want to unsubscribe from the previous execution of our <code>trigger$</code> and execute it again. Let’s see how we can do this in the code:</p>

<pre><code>load$ = new BehaviorSubject('');

this.polledBitcoin$ = this.load$.pipe(
      switchMap(_ =&gt; timer(0, 10000).pipe(
         concatMap(_ =&gt; bitcoin$),
         map((response: {EUR: {last: number}}) =&gt; response.EUR.last),
      )
   )
);
</code></pre>
<p>First thing we need to change is move from a <code>Subject</code> to a <code>BehaviorSubject</code>. A <code>BehaviorSubject</code> has an initial value and will replay the last value when subscribed to. Here, we are interested in the fact that it has an initial value.</p>

<p>Next thing we do is use this subject to create our <code>polledBitcoin$</code>. We wrapped the stream from our previous examples in a <code>switchMap</code>. Whenever the <code>load$</code> emits, this stream will be started. If there was a previous execution still working, this execution will be stopped in favor of a new one. And that’s exactly what we need. Thanks to the initial value in the <code>BehaviorSubject</code>, we know that the stream will be started whenever the stream is initially subscribed to.</p>

<p>Now, whenever the user clicks on the reload button, the data will be fetched and the timer is reset! We can use this technique in different scenarios as well. For example, when the user swipes down on a mobile device. Nice right!</p>

<p>You can find the example code here:</p>
<iframe src="https://stackblitz.com/edit/angular-srtgmv" style="width: 100%; height: 500px"></iframe>

<h3 id="polling-when-data-is-resolved">Polling when data is resolved</h3>

<p>The last polling strategy I want to take a look at is one where we only start a next request after the first one has finished plus ‘x’ seconds. This can be helpful in some cases.</p>

<p>With the previous example in mind, Let’s say we poll every 5 seconds and at one point, our backend call takes 4 seconds. This would mean that, 1 second after we finally gotten our result, we fetch it again. This might not always be what we want.</p>

<p>Again, Let’s start by thinking about what we want in a reactive way. First of all, we need to know when our backend call has ended. When it has ended, we need to wait ‘x’ seconds before starting the next one. Let’s break it down.</p>

<p>Knowing when our backend call has ended is pretty easy. Whenever a value passes the <code>bitcoin$</code>, we know the backend call is done. After that has happened, we need to create a stream that, waits ‘x’ seconds and then triggers a new call. Let’s try and create a stream that, when subscribed to, waits 5 seconds, has the option to trigger a new call and then completes.</p>

<pre><code class="language-typescript">load$ = new BehaviorSubject('');

const whenToRefresh$ = of('').pipe(
      delay(5000),
      tap(_ =&gt; load$.next(''),
      skip(1),
);
</code></pre>

<p>We created a stream using the static <code>of</code>. This will fire an event immediately when subscribed to. We then delay this event with 5000ms by using the <code>delay</code> operator. We then use a <code>tap</code> where we can actually trigger the next request, and finally <code>skip</code> since we do not want to use the <code>''</code> event anywhere, it was just a trigger.</p>

<p>Next thing we need to do is integrate this into our other code. Let’s see how we can accomplish this:</p>

<pre><code class="language-typescript">const poll$ = concat(bitcoin$, whenToRefresh$);

this.polledBitcoin$ = this.load$.pipe(
  concatMap(_ =&gt; poll$),
  map((response: {EUR: {last: number}}) =&gt; response.EUR.last),
);
</code></pre>

<p>We removed the <code>timer</code> operator here and replaced it with our <code>BehaviorSubject</code>. We changed our stream inside the <code>concatMap</code> operator. Here we used <code>concat</code> to combine the <code>bitcoin$</code> with our <code>whenToRefresh$</code> we created above. What <code>concat</code> does is, execute the <code>bitcoin$</code> first and whenever that one completes, starts the other stream.</p>

<p>This is ideal, since we need to wait for the <code>whenToRefresh$</code> to start till the backend call completes. When it completed, the <code>whenToRefresh$</code> is started and will wait 5000ms and then next the <code>load$</code> to start the whole thing again.</p>

<p>Drawn out into an ASCII marble diagram, it looks like this.</p>

<pre><code>bitcoin$:         -----(b|)
load$:       f-------------f-------------f....
(poll$)                    \
(poll$)      \              -----b-------N....
              -----b-------N
                   
                   
polledBitcoin$:   ------b-------------b-------....
</code></pre>

<p>We can see that, whenever the first backend call was started, we wait 5000ms (here an amount of ‘-‘) before next’ing the <code>load$</code> to start the thing again.</p>

<p>A live example of the code can be found here:</p>

<iframe src="https://stackblitz.com/edit/angular-4nqhgq?embed=1&amp;file=src/app/app.component.ts" style="width: 100%; height: 500px"></iframe>

<p><strong>Note:</strong> to really see that the next call is only scheduled 5000ms after the previous one finished, you can use the network tab and throttle the network to ‘slow 3g’.</p>

<h3 id="conclusion">Conclusion</h3>

<p>RxJS and polling is a match made in heaven. There a number of different ways to implement polling which all have there trade offs. Understanding the differences between the ones described above will get you a long way.</p>


	  ]]></description>
	</item>

	<item>
	  <title>What are schedulers in RxJS</title>
	  <link>//what-are-schedulers-in-rxjs/</link>
	  <author></author>
	  <pubDate>2018-02-05T00:00:00+00:00</pubDate>
	  <guid>//what-are-schedulers-in-rxjs/</guid>
	  <description><![CDATA[
	     <p>One topic in RxJS for which it is quite hard to find proper documentation/blogposts, is ‘Schedulers’. ‘Schedulers’ are a way to control the timing strategy used to execute tasks. The main reason for this is that the authors of RxJS did a great job in abstracting this logic. They used the principle of least concurrency as the default scheduling strategy which makes sure that in most cases, we don’t have to think about changing the default.</p>

<p>This post will examine the different schedulers and explain the differences between them.</p>

<h2 id="async-in-javascript">Async in javascript</h2>
<p>To understand the difference between the different schedulers, we must first examine how async works in javascript. No worries, we won’t go in too deep :).</p>

<p>Javascript is a single threaded language that uses an event loop to handle asynchronous operations. One of my favorite talks ever covers this topic really well. It’s by Philip Roberts and you can find a recording <a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" target="_blank">here</a>. Be sure to check it out if you are unsure what the event loop is and how it works.</p>

<h3 id="understanding-by-example">Understanding by example</h3>

<p>Let’s look at an example.</p>

<pre><code class="language-typescript">console.log('script start');

setTimeout(function() {
  console.log('setTimeout');
}, 0);

Promise.resolve().then(function() {
  console.log('promise1');
}).then(function() {
  console.log('promise2');
});

console.log('script end');
</code></pre>

<p>If you run this piece of code, the result will look like this:</p>

<pre><code class="language-typescript">script start
script end
promise1
promise2
setTimeout
</code></pre>
<p>If you know how the event loop works, you understand that ‘script start’ and ‘script end’ were logged first. The ‘setTimeout’ and ‘promises’ that get triggered were put on a queue to be executed when the call stack cleared.</p>

<p>But what’s a lesser known fact is that there are different queues. There is a microtask and a macrotask queue. A promise gets added to the microtask queue and a setTimeout to the macrotask queue.
Whenever the call stack is cleared, the microtasks queue gets cleared first. Hence the ‘promise1’ is the next log statement we see.</p>

<p>When a microtask is finished, the rest of the microtasks queue gets executed until the microtask queue is empty. That’s the reason ‘promise2’ is logged next. So even if the second promise gets scheduled during the execution of the first, it still gets executed before the setTimeout.</p>

<p>Lastly, when the microtask queue is cleared, the next task is picked from the macrotask queue, and the ‘setTimeout’ is logged.</p>

<p>There you have it, this is how async works in javascript! Might be a little to quick but since it’s not part of this post to explain everything in detail, I’ll leave it at that. And also because Jake Archibald basically explained it in perfect detail right <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank">here</a>.</p>

<h2 id="schedulers">Schedulers</h2>

<p>In RxJS there are different schedulers that all schedule work using a different (a)sync technique behind the scenes. Let’s take a look at an example to learn a few of them. There are three statement logged on different schedulers.</p>

<pre><code class="language-typescript">const asyncScheduler = Rx.Observable.of('')
  .startWith('async', Rx.Scheduler.async);

const asapScheduler = Rx.Observable.of('')
  .startWith('asap', Rx.Scheduler.asap);

const queueScheduler = Rx.Observable.of('')
  .startWith('queue', Rx.Scheduler.queue);


Rx.Observable.merge(
    asyncScheduler,
    asapScheduler,
    queueScheduler)
  .filter(x =&gt; !!x)
  .subscribe(console.log);

console.log('after subscription')
</code></pre>

<p>The results of running this code is:</p>

<pre><code class="language-typescript">queue
after subscription
asap
async
</code></pre>

<p>As you can see, the ‘queue’ is the only statement logged synchronously. We can conclude this because it is the only statement logged before the ‘after subscription’ statement is logged. 
Next we can see that the ‘asap’ is logged before the ‘async’. That is because the <code>asap</code> scheduler uses the micro task queue and the <code>async</code> uses the macrotask queue.</p>

<p>Now, to list all of them, we can look at the table below. In the example I didn’t cover the ‘animationFrame’ and the ‘virtualTime’ scheduler. The ‘animationFrame’ scheduler allows you to schedule work to be executed when there is a repaint. The ‘virtualTime’ scheduler is something you can use to test your code in a synchronous fashion using marble diagrams.</p>

<table>
  <thead>
    <tr>
      <th>Scheduler</th>
      <th>Approach</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>Queue</code></td>
      <td>Executes task synchronously but waits for current task to be finished</td>
    </tr>
    <tr>
      <td><code>Asap</code></td>
      <td>Schedules on the micro task queue</td>
    </tr>
    <tr>
      <td><code>Async</code></td>
      <td>Schedules on the macro task queue</td>
    </tr>
    <tr>
      <td><code>AnimationFrame</code></td>
      <td>Relies on ‘requestAnimationFrame’</td>
    </tr>
    <tr>
      <td><code>VirtualTime</code></td>
      <td>Will execute everything synchronous ordered by delay and mainly used in testing</td>
    </tr>
  </tbody>
</table>

<h3 id="using-schedulers-in-rxjs">Using schedulers in RxJS</h3>
<p>Some operators, like ‘startWith’ in the example above, allow you to pass in an optional scheduler to influence when a certain task gets executed. Every operator that has this option, will also have a default value.</p>

<p>For example, the <code>debounceTime</code> operator uses the ‘async’ scheduler as a default as you can see below.</p>

<pre><code class="language-typescript">export function debounceTime&lt;T&gt;(dueTime: number, scheduler: IScheduler = async)
</code></pre>

<h2 id="conclusion">Conclusion</h2>
<p>Schedulers influence the timing on which tasks get executed. You can change the default schedulers of some operators by passing in an extra scheduler argument.</p>


	  ]]></description>
	</item>

	<item>
	  <title>RxJS best practices in Angular</title>
	  <link>//rxjs-best-practices-in-angular/</link>
	  <author></author>
	  <pubDate>2018-01-04T00:00:00+00:00</pubDate>
	  <guid>//rxjs-best-practices-in-angular/</guid>
	  <description><![CDATA[
	     <p>This article is all about the do’s and don’ts when it comes to writing reactive applications with <a href="http://reactivex.io/">RxJS</a> in <a href="https://angular.io/">Angular</a> applications. 
The best practices described in this article are based on personal experiences and can be assumed as personal opinions.</p>

<p>The topics we will tackle in this article are:</p>
<ul>
  <li><a href="#learning-how-to-think-reactive">Learning how to think reactive</a></li>
  <li><a href="#pipeable-operators">Pipeable operators</a></li>
  <li><a href="#ascii-marble-diagrams">ASCII marble diagrams</a></li>
  <li><a href="#using-pure-functions">Using pure functions</a></li>
  <li><a href="#avoiding-memory-leaks">Avoiding memory leaks</a></li>
  <li><a href="#avoiding-nested-subscribes">Avoiding nested subscribes</a></li>
  <li><a href="#avoiding-manual-subscribes-in-Angular">Avoiding manual subscribes in Angular</a></li>
  <li><a href="#dont-pass-streams-to-components-directly">Don’t pass streams to components directly</a></li>
  <li><a href="#dont-pass-streams-to-services">Don’t pass streams to services</a></li>
  <li><a href="#sharing-subscriptions">Sharing subscriptions</a></li>
  <li><a href="#when-to-use-Subjects">When to use Subjects</a></li>
  <li><a href="#cleancode-practices">Clean-code practices</a></li>
  <li><a href="#Angular-embraces-RxJS">Angular embraces RxJS</a></li>
</ul>

<p><strong>Note:</strong>
We will refer to observables as streams in this article.
Since the streams in this article use the <code>$</code>-suffix, a short explanation.
First of all, there is a lot of debate about the <code>$</code>-suffix but I believe this should be a personal preference. 
The reason why I prefer to use it, is because I find it very easy to separate streams from regular objects.
That being said, I would not consider it a best practice, just a personal choice.</p>

<h2 id="learning-how-to-think-reactive">Learning how to think reactive</h2>

<p>Reactive programming is completely different than imperative programming. It requires us to make a certain mind switch.
This mind switch is rather important if we want to benefit from RxJS completely.
We want to <strong>stop thinking in specific actions</strong> and we want to <strong>start thinking in streams</strong>. 
It requires us to forget a part of practices that we already know (at least for a moment).
In <a href="http://blog.brecht.io/Creating-reactive-calendar-in-angular4/">this article</a> we can find some tips and practical examples on how to start thinking reactive in RxJS.</p>

<h2 id="pipeable-operators">Pipeable operators</h2>

<p>The first best practice is the use of pipeable operators. The operators being used in this article are pipeable.
Since version 5.5 RxJS has introduced these so called pipeable operators which are easier to import than patch operators, and
also have <a href="https://webpack.js.org/guides/tree-shaking/">treeshaking</a> advantages. More information about pipeable operators can be found <a href="https://blog.angularindepth.com/rxjs-understanding-lettable-operators-fe74dda186d3">here</a> and <a href="https://blog.hackages.io/rxjs-5-5-piping-all-the-things-9d469d1b3f44">here</a>.</p>

<p>This example illustrates the difference between doing it the old way and the new way.</p>

<pre><code class="language-typescript">// BAD: This is the old way and should be avoided (patch operators)
// as we can see the operators (filter, map) are part of the
// Observable prototype
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/map';
const new$ = Observable.interval$
    .filter(v =&gt; v % 2 === 0)
    .map(v =&gt; v * 2);

// GOOD: This is the new and improved way (lettable operators)
// we just use the pipe operator where we pass operators that
// we can import from 'rxjs/operators'
import {filter, map} from 'rxjs/operators';
const new$ = interval$
    .pipe(
        filter(v =&gt; v % 2 === 0),
        map(v =&gt; v *2)
    )
</code></pre>

<h2 id="ascii-marble-diagrams">ASCII marble diagrams</h2>

<p>Some developers tend to say: “Great code should be self-explanatory, writing documentation is something that we might want to avoid.”
In some cases I would agree with that statement, but for complex RxJS code we might want to reconsider.
Streams can become complex in the following scenarios:</p>
<ul>
  <li>When we take the lifecycle of streams into account, (how long do they live? when do they start living? what destroys them?)</li>
  <li>When we start combining streams (every stream has a different lifecycle remember?)</li>
  <li>When we subscribe multiple times or even subscribe after a while, or even never subscribe to them</li>
</ul>

<p><a href="http://rxmarbles.com/">marble diagrams</a> are a cool way of visualising streams but it’s hard to put those marble-diagrams in our code right?!
There is an ASCII variant of these marble-diagrams that we can use to describe and document our complex streams and how they interact with each other.</p>

<p>ASCII diagrams have more advantages then just documenting:</p>
<ul>
  <li>It gives us a graphic thinking model</li>
  <li>It becomes easy to review someones code and validate to see if it really does what it’s supposed to be doing</li>
  <li>Great to draw on a whiteboard before we start coding</li>
  <li>You can type them in your IDE or editor before you actually start coding. (An easy way to trick your mind into thinking reactively)</li>
  <li>We can use them to write unit tests as well: <a href="http://blog.kwintenp.com/how-to-setup-marble-testing/">Checkout this awesome article</a></li>
</ul>

<p>The concepts behind ASCII marble documentation are quite simple. Take this easy example for instance:</p>

<pre><code class="language-typescript">// ---a--b--c--d---e---...
// ---a--b--c--d---e|
// ---a--b--c--d---e#
// ---a--b-^-c--d---e
</code></pre>
<ul>
  <li><code>-</code> (stands for a time frame)</li>
  <li><code>a-z</code> (are the values that are next’ed in the stream)</li>
  <li><code>|</code> (indicates that the stream has completed)</li>
  <li><code>...</code> (indicates that the stream will keep on living)</li>
  <li><code>#</code> (indicates that an error occurred)</li>
  <li><code>^</code> (indicates where we start subscribing (only for hot streams)</li>
</ul>

<p>Perhaps it’s time to check a real example and how we might document it:</p>

<pre><code class="language-typescript">const interval$ = interval(1000)            // 0--1--2--3--4--5--6...
const new$ = interval$
    .pipe(
        skip(1),                            // ---1--2--3--4--5--6...
        take(5),                            // ---1--2--3--4--5|
        filter(v =&gt; v % 2 === 0),           // ------2-----4-----6
        map(v =&gt; v + 1)                     // ------3-----5-----7
    )
</code></pre>

<p>Take a minute to let this sink into your brain, because this might be <strong>THE WAY</strong> of making a complex code snippets readable for anyone.
When we take a look at this diagram, it’s fairly easy to comprehend what happens, and how every operator affects the <code>new$</code> stream we can see above. There is no “one way of doing things” when it comes to writing ASCII marble-diagrams. You can put them where and how you want.
As we want to do for all other documentation: <strong>keep it up to date!</strong></p>

<h2 id="using-pure-functions">Using pure functions</h2>

<p>RxJS follows the concepts of functional reactive programming which basically means that we will use <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976">pure functions</a> to create our reactive flow.
A function is pure when:</p>
<ul>
  <li>It doesn’t mutate anything</li>
  <li>It will always return the same value based on the same parameters</li>
  <li>It doesn’t have any side effects. It can’t mutate state outside of the function</li>
</ul>

<p>In the beginning it might seem pragmatic to use side effects, but that mostly means we aren’t fully thinking reactively. 
Therefore avoid side effects at much as possible.</p>

<h2 id="avoiding-memory-leaks">Avoiding memory leaks</h2>

<p>To consume a stream we need to <strong>subscribe</strong> to that stream. When we subscribe to that stream a <strong>subscription</strong> will be created.
That subscription will keep on living until the stream is <strong>completed</strong> or until we <strong>unsubscribe manually</strong> from that stream.
Managing subscriptions is very important and in a number of cases we will have to manually unsubscribe an existing subscription to avoid memory leaks. Take this example for instance:</p>

<pre><code class="language-typescript">class AppComponent implements OnInit {
   ngOnInit() {
        // The following stream will produce values every second
        // 0--1--2--3--4--5--6--...
        const interval$ = interval(1000);
        // Even when this component gets destroyed,
        // the stream will keep producing values...
        // This means the console will keep on logging
        // This is a classic example of a memory-leak
        const subscription = interval$.subscribe(r =&gt; console.log(r));
    }
}
</code></pre>

<p>To remove the memory-leak in this component we can keep track of the subscriptions by taking advantage of the <code>ngOnDestroy()</code> lifecycle hook of Angular:</p>

<pre><code class="language-typescript">class AppComponent implements OnInit, OnDestroy {
    subscriptions = [];
    ngOnInit() {
        const interval$ = interval(1000);
        const subscription = interval$.subscribe(r =&gt; console.log(r));
        // manually keep track of the subscriptions in a subscription array
        this.subscriptions.push(subscription);
    }

    ngOnDestroy() {
        // when the component get's destroyed, unsubscribe all the subscriptions
        this.subscriptions.forEach(sub =&gt; sub.unsubscribe());
    }
}
</code></pre>

<p>However, when we are using a bunch of subscriptions, it can become quite dirty. Before, we talked about the fact that a subscription will live until we manually unsubscribe (like we just did in the snippet above), but also until the stream gets <strong>completed</strong>. A cool way to handle this issue is to use a Subject that we next in the <code>ngOnDestroy()</code> lifecycle hook of Angular:</p>

<pre><code class="language-typescript">class AppComponent implements OnInit, OnDestroy {
    destroy$ = new Subject();
    ngOnInit() {
        // interval$: 0--1--2--3--4--5--6--...
        // destroy$:  -------------true|
        // result:    0--1--2--3--4|
        const interval$ = interval(1000);
        interval$
            // let the interval$ stream live 
            // until the destroy$ Subject gets a value
            .pipe(takeUntil(this.destroy$))
            .subscribe(r =&gt; console.log(r));
    }

    ngOnDestroy() {
        // when the component get's destroyed, pass something to the
        // destroy$ Subject
        this.destroy$.next(true);
    }
}
</code></pre>

<h2 id="avoiding-nested-subscribes">Avoiding nested subscribes</h2>

<p>Nesting subscribes is something that needs to be avoided as much as possible. It makes the code unreadable, complex, and introduces side effects.
It basically forces you to <strong>NOT</strong> think reactively. Take this Angular example for instance:</p>

<pre><code class="language-typescript">class AppComponent {
    user: User;
    constructor(
        private route: ActivatedRoute, 
        private userService: UserService)
    {
        // when the params of the route changes,
        // we want to fetch the user and set the user property
        //
        // VERY BAD: nesting subscribes is ugly and takes away
        // the control over a stream
        this.route.params
            .pipe(map(v =&gt; v.id))
            .subscribe(id =&gt; 
                this.userService.fetchById(id)
                    .subscribe(user =&gt; this.user = user))
    }
}
</code></pre>

<p>The previous implementation is considered a bad-practice. It’s recommended to use <strong>higher-order streams</strong> like <code>mergeMap</code> or <code>switchMap</code>. Let’s have a look at this example:</p>

<pre><code class="language-typescript">class AppComponent {
    user: User;
    constructor(
        private route: ActivatedRoute, 
        private userService: UserService) 
    {
        // when the params of the route changes,
        // we want to fetch the user and set the user property
        //
        // GOOD: we have created a single subscribe which makes
        // the flow way easier and gives us the control we need
        this.route.params
            .pipe(
                map(v =&gt; v.id),
                switchMap(id =&gt; this.userService.fetchById(id))
            )
            .subscribe(user =&gt; this.user = user)
    }
}
</code></pre>

<h2 id="avoiding-manual-subscribes-in-angular">Avoiding manual subscribes in Angular</h2>

<p>To consume a stream we need to subscribe that stream, that’s simply how observables work. But what if a component needs values from 5 different streams… Would that mean, that we want to subscribe to all of these streams and manually map all the values to unique properties, just to make it work? That would suck, right?!</p>

<p>Angular has this super cool feature called the <code>async pipe</code>. It’s used to consume streams directly in the template
The async pipe does 3 things for us:</p>
<ul>
  <li>It subscribes to the stream and passes the value to a component</li>
  <li>It <strong>unsubscribes automatically</strong> when the component gets destroyed (removes a lot of unsubscribe logic)</li>
  <li>Triggers change detection automatically</li>
</ul>

<p>This means we don’t have to manually subscribe nor unsubscribe anymore. Which cleans up the code a lot.
Let’s have a look at the cleaned up previous example:</p>

<pre><code class="language-typescript">@Component({
    ...
    template: `
        &lt;user-detail [user]="user$|async"&gt;&lt;/user-detail&gt;
    `
})
class AppComponent {
    // expose a user$ stream that will be 
    // subscribed in the template with the async pipe
    user$ = this.route.params.pipe(
        map(v =&gt; v.id),
        switchMap(id =&gt; this.userService.fetchById(id))
    );

    constructor(
        private route: ActivatedRoute, 
        private userService: UserService) {
    }
}
</code></pre>

<p>If you are into <a href="https://reactjs.org/">React</a>, I’ve created this lib called <a href="https://www.npmjs.com/package/react-rx-connect">react-rx-connect</a> that would solve this problem. It binds the streams to the state, and unsubscribes from them when the component gets destroyed.</p>

<h2 id="dont-pass-streams-to-components-directly">Don’t pass streams to components directly</h2>

<p>One of the most important aspects of software architecture might be the concept of <strong>decoupling</strong> pieces of code.
Therefore we could consider passing streams to child components as a <strong>bad practice</strong> because it creates a very tight link between the parent component and the child component. They are no longer decoupled since subscriptions in the child component might trigger actions in the parent component. We never want the child component to be responsible of initiating data calls right?! That’s the task of the smart component. See the difference between
<a href="http://blog.brecht.io/components-demystified/#smart-vs-dumb-components">smart and dumb components here</a>.
A component should always receive an object or value and should not even care if that object or value comes from a stream or not.</p>

<pre><code class="language-typescript">// BAD
// app.component.ts
@Component({
    selector: 'app',
    template: `
        &lt;!-- 
            BAD: The users$ steram is passed
            to user-detail directly as a stream 
        --&gt;
        &lt;user-detail [user$]="user$"&gt;&lt;/user-detail&gt;
    `
})
class AppComponent {
    // this http call will get called when the 
    // user-detail component subscribes to users$
    // We don't want that
    users$ = this.http.get(...);
    ...
}

// user-detail.component.ts
@Component({
    selector: 'user-detail',
    template: `
        
    `
})
class UserDetailComponent implements OnInit {
    @Input() user$: Observable&lt;User&gt;;
    user: User;
    ngOnInit(){
        // WHOOPS! This child component subscribes to the stream
        // of the parent component which will do an automatic XHR call
        // because Angular HTTP returns a cold stream
        this.user$.subscribe(u =&gt; this.user = u);
    }
}
</code></pre>

<p>It would be better to handle the subscription in the parent component itself:</p>

<pre><code class="language-typescript">// GOOD
// app.component.ts
@Component({
    selector: 'app',
    template: `
        &lt;user-detail [user]="user$|async"&gt;&lt;/user-detail&gt;
    `
})
class AppComponent implements OnInit {
    users$: Observable&lt;User[]&gt; = this.http.get(...);
    user: User;
    ngOnInit(){
        // the app component (smart) subscribes to the user$ which will
        // do an XHR call here
        this.users$ = this.http.get(...);
    }
    ...
}

// user-detail.component.ts
@Component({
    selector: 'user-detail',
    template: `
        
    `
})
class UserDetailComponent {
    // This component doesn't even know that we are using RxJS which
    // results in better decoupling
    @Input() user: User;
}
</code></pre>

<p>The responsibility of the component is clear. The user-detail is meant to be dumb and is completely decoupled from its parent.</p>

<p>There are however situations where we would like to create a stream from an input. In that case we could take a look at this library: <a href="https://www.npmjs.com/package/ngx-reactivetoolkit">ngx-reactivetoolkit</a></p>

<h2 id="dont-pass-streams-to-services">Don’t pass streams to services</h2>

<p>Although, it might seem like a pragmatic solution to pass streams directly to services, it could be seen as a <strong>bad practice</strong> if we consider the decoupling again. By passing a stream to a service we don’t know what’s going to happen to it. The stream could be subscribed to, or even combined with another stream that has a longer lifecycle, that could eventually determine the state of our application.
Subscriptions might trigger unwanted behavior. And after all, services don’t care that your components are using streams. Take this example for instance:</p>

<pre><code class="language-typescript">// BAD
// app.component.ts
class AppComponent {
     users$ = this.http.get(...)
     filteredusers$ = this.fooService
        .filterUsers(this.users$); // Passing stream directly: BAD
    ...
}

// foo.service.ts
class FooService {
    // return a stream based on a stream
    // BAD! because we don't know what will happen here
    filterUsers(users$: Observable&lt;User[]&gt;): Observable&lt;User[]&gt; {
        return users$.pipe(
            map(users =&gt; users.filter(user =&gt; user.age &gt;= 18))
    }
}
</code></pre>

<p>It would be better to use higher order streams for these situations.
Use <code>switchMap</code> over <code>mergeMap</code> if possible, since it will unsubscribe the previous stream.
The following example is better since all the RxJS logic is centralized in one place where the subscribing and unsubscribing happens: The smart component.</p>

<pre><code class="language-typescript">// GOOD
// app.component.ts
class AppComponent {
    users$ = this.http.get(...)
    filteredusers$ = this.users$
        .pipe(switchMap(users =&gt; this.fooService.filterUsers(users)));
    ...
}

// foo.service.ts
class FooService {
    // this is way cleaner: this service doesn't even know
    // about streams now
    filterUsers(users: User[]): User[] {
        return users.filter(user =&gt; user.age &gt;= 18);
    }
}
</code></pre>

<h2 id="sharing-subscriptions">Sharing subscriptions</h2>

<p>Since most streams are cold by default, every subscription will trigger the <strong>producer</strong> of these streams.
The execution of the producer logic on every subscription, might not be what we want if we have multiple subscriptions.
Eg. Subscribing to Angular its <code>http.get()</code> multiple times will actually perform multiple xhr calls.
The following example will trigger the xhr call twice because <code>numberOfUsers$</code> depends on <code>users$</code>.</p>

<pre><code class="language-typescript">@Component({
    selector: 'app',
    template: `
        Number of users: {{numberOfUsers$|async}}
        &lt;users-grid [users]="users$|async"&gt;&lt;/users-grid&gt;
    `
})
// BAD
class AppComponent {
    users$ = this.http.get(...)
    // the subscription on this stream will execute the xhr call again
    numberOfUsers$ = this.users$.pipe(map(v =&gt; v.length); 
}
</code></pre>

<p>In those cases we might want to share the subscriptions. The following example uses the <code>share()</code> operator:</p>

<pre><code class="language-typescript">@Component({
    selector: 'app',
    template: `
        Number of users: {{numberOfUsers$|async}}
        &lt;users-grid [users]="users$|async"&gt;&lt;/users-grid&gt;
    `
})
// GOOD
class AppComponent {
    users$ = this.http.get(...).pipe(share());
    // the subscription on this stream will execute the xhr call again
    numberOfUsers$ = this.users$.pipe(map(v =&gt; v.length); 
}
</code></pre>

<p>Sharing a stream makes it hot. This means that if we subscribe after the value is produced, we will miss that value.
In that case we might want to use <code>shareReplay(1)</code> instead of <code>share()</code>. This will keep the last value in memory for us.</p>

<p>It’s a common mistake to share everything. We don’t always want to work with hot streams and sharing subscriptions comes with a small performance cost.Also, lazy streams have their advantages.</p>

<p>Angular also provides a <em>great alternative</em> that can reduce the sharing of streams to a minimum by using the <code>async as else</code> syntax.. 
Personally I would consider the use of this feature as a best practice.
The following example reduces the number of streams, the number of subscriptions and gives us <strong>an easy way to show a loading indicator</strong>.</p>

<pre><code class="language-typescript">@Component({
    selector: 'app',
    template: `
        &lt;div *ngIf="users$|async as users; else loading"&gt;
            Number of users: 
            &lt;users-grid [users]="users"&gt;&lt;/users-grid&gt;
        &lt;/div&gt;
        &lt;ng-template #loading&gt;Loading...&lt;/ng-template&gt;
    `
})
class AppComponent {
    // This stream will only subscribed to once
    users$ = this.http.get(...);
}
</code></pre>

<h2 id="when-to-use-subjects">When to use Subjects</h2>

<p>A Subject is both a hot observable and an observer at the same time. This gives us the opportunity to next values into the stream ourselves.
Subjects tend to be overused by people that didn’t make the mind switch towards reactive programming yet.</p>

<p>Only use them when really needed, for instance it’s ok to use Subjects in the following scenarios:</p>
<h4 id="when-mocking-streams-in-tests">When mocking streams in tests</h4>

<pre><code class="language-typescript">const fetchAll$ = new Subject(); // use a Subject as a mock
usersServiceMock.fetchAll.mockReturnValue(fetchAll$);
fetchAll$.next(fakeUser);
</code></pre>

<h4 id="when-we-want-to-create-streams-from-outputs-in-angular">When we want to create streams from outputs in Angular</h4>

<pre><code class="language-typescript">@Component({
    ...
    template: `
    &lt;some-component (search)="search$.next($event)"&gt;&lt;/some-component&gt;
    `
})
class AppComponent {
search$ = new Subject(); // ----t-----te-----ter----term...
}
</code></pre>

<h4 id="when-handling-circular-references">When handling circular references</h4>

<p>I’m not going to dive in this to deep, but <a href="">Dominic Elm</a> does an awesome job explaining this in <a href="https://blog.thoughtram.io/rxjs/2017/08/24/taming-snakes-with-reactive-streams.html#behaviorsubject-to-the-rescue">this great article</a></p>

<p>For most other cases an operator or Observable.create might be enough.</p>

<p><strong>Note:</strong>
A BehaviorSubject is commonly used because it has a <code>getValue()</code> function. That would also be considered a bad practice.
When we are trying to fetch a specific value it usually means we are not thinking reactive.</p>

<h2 id="clean-code-practices">Clean code practices</h2>
<p>Consistent code indentation and formatting can improve the readability of complex streams:</p>
<ul>
  <li>Align operators below each other</li>
</ul>

<pre><code class="language-typescript">    foo$.pipe(
        map(...)
        filter(...)
        tap(...)
    )
</code></pre>

<ul>
  <li>Extract into different streams when it becomes unreadable</li>
  <li>Put complexer functionality in private methods (make the reactive flow clear)</li>
  <li>Avoid the use of brackets for readability, that’s personal preference.</li>
</ul>

<h2 id="angular-embraces-rxjs">Angular embraces RxJS</h2>

<p>We already saw a glimpse of why Angular is a framework that really embraces the use of RxJS.
Therefore it’s recommended to use the functionality that Angular provides.</p>
<ul>
  <li>The <code>ActivatedRoute</code> has exposes a params stream.</li>
  <li>The Http and HttpClient both return streams</li>
  <li>The <code>Form</code> and <code>FormControl</code> both have a <code>valueChanges</code> property that returns a stream</li>
  <li>The async pipe is an awesome feature that really helps us to use the streams in our templates</li>
  <li>Using the <code>ngOnInit()</code> lifecycle function to initialize streams can help us for mocking purposes</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>Still here? Awesome! We learned a lot! If this article interests you, you might want to check out the “Advanced RxJS in Angular workshop” from <a href="https://strongbrew.io">Strongbrew</a>, where me and <a href="blog.kwintenp.com">Kwinten Pisman</a> teach how to use advanced RxJS in real Angular applications.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Code formatting and RxJS</title>
	  <link>//code-formatting-with-rxjs/</link>
	  <author></author>
	  <pubDate>2017-09-08T00:00:00+00:00</pubDate>
	  <guid>//code-formatting-with-rxjs/</guid>
	  <description><![CDATA[
	     <p>One of the main benefits of RxJS to me is that it provides code that is ‘readable’. It provides us with a declarative programming approach where implementation details are hidden away. We are just describing what needs to be done, not how it should be done. This makes code you look at easy to understand.</p>

<p>One problem that I face regularly when looking at other peoples code is that the code formatting or the way the (RxJS) code is written, takes away part of the benefit of writing your code this way. This post is a small summary on how I like to format my code to keep the readability benefits to a maximum.</p>

<h3 id="one-operator-per-line">One operator per line</h3>

<p>One thing I see all the time is something like this:</p>

<pre><code class="language-typescript">Rx.Observable.pipe(interval(1000),map(x =&gt; x*2),filter(x =&gt; x%2 === 0),
	mergeMap(x =&gt; someBackendCall(x)),map(res =&gt; res.json()).subscribe();
</code></pre>

<p>Here we can see a simple stream. Looking at what is does is a little more difficult however because of the outlining of the operators. If you format the code like this, it makes it so much easier:</p>

<pre><code class="language-typescript">Rx.Observable.interval(1000)
   .pipe(
	   map(x =&gt; x*2),
	   filter(x =&gt; x%2 === 0),
	   mergeMap(x =&gt; someBackendCall(x)),
	   map(res =&gt; res.json())
	)
	.subscribe();
</code></pre>

<p>By putting every operator on a new line, it is so much easier to see what’s happening.</p>

<h3 id="using-nested-functions-for-functions-longer-than-one-line">Using nested functions for functions longer than one line</h3>

<p>A lot of the RxJS operators will accept functions as parameters. These functions can influence the code formatting and impair the readability. Let’s take a look at an example:</p>

<pre><code class="language-typescript">// A data$ stream
private data$: Observable&lt;Array&lt;Data&gt;&gt;;

// A function that uses this data$ 
doSomething() {
    this.data$
    	.pipe(
    	   take(1),
           map((data) =&gt; {
               if (data &amp;&amp; data.length &gt; 0) {
                   	return data.forEach(datum =&gt; {
                       datum.active = false;
                    });
               } else {
            		return [];
               }
           }),
           mergeMap((data) =&gt; {
               data.forEach(datum =&gt; {
                   this.whateverService.update(data);
               });
           })
        )
        .subscribe();
}
</code></pre>

<p>We have a function <code>doSomething()</code> that, when called, will use the <code>data$</code> stream as a source and will perform a mapping of the data array events inside of this stream and then will perform a backend call for every element inside this array. 
If you were able to detect this immediately, my hat off to you. To me however, this looks pretty bad. Let’s take a look at how we could make this better:</p>

<pre><code class="language-typescript">// A data$ stream
private data$: Observable&lt;Array&lt;Data&gt;&gt;;

// A function that uses this data$ 
doSomething() {
    const mapAllTheElementsActiveFlagToFalse = (data) =&gt; {
        if (data &amp;&amp; data.length &gt; 0) {
            return data.forEach(datum =&gt; {
                datum.active = false;
            });
        } else {
            return [];
        }
    };

    const callTheWhateverServiceForEveryElement = (data) =&gt; {
        data.forEach(datum =&gt; {
            this.whateverService.update(data);
        });
    }; 

    this.data$
    	.pipe(
    	  take(1),
          map(mapAllTheElementsActiveFlagToFalse),
          mergeMap(callTheWhateverServiceForEveryElement)
       ).subscribe();
}
</code></pre>

<p>I updated the code so that all the functions passed to the operators are first created as nested functions. This might feel a little weird at first, creating nested functions, but if we look at the last few lines of code, these have become so much cleaner. If you know what the operators of RxJS do, you can actually read what is happening (I must admit, naming these functions might not be my strongest feat :)). You only have to look at the last lines of this function. The implementation details of the nested functions is irrelevant (remember, declarative is easier to read).
I find this approach really helpful and tend to use it a lot, especially for functions that are longer than a single line.</p>

<h3 id="avoid-using-nested-observables">Avoid using nested observables</h3>

<p>RxJS provides us with a lot of operators which you can do a whole range of stuff with. One of them is combining different streams. One thing I sometimes see is this:</p>

<pre><code class="language-typescript">private data$: Observable&lt;Array&lt;Data&gt;&gt;;
private data2$: Observable&lt;Data2&gt;;

result$: Observable&lt;any&gt;;

doSomething() {
	 // we combine the data$ and data2$ with combineLatest
    this.result$ = combineLatest(
        this.data$
            .pipe(
               map(data =&gt; data.length),
            ),
        this.data2$
            .pipe(
               mergeMap(val =&gt; this.whateverService.call(val)),
            ),
        (val1, val2) =&gt; {
            // handle the values here   
        }
    );
}
</code></pre>

<p>We create an observable by using the <code>combineLatest</code> operator. But before we do so, the <code>data$</code> and <code>data2$</code> streams are transformed. You could say we are working with nested streams. And even though, the operators are aligned perfectly and there are no functions that are longer than one line, it still feels weird. Let’s see how we might be able to make it better:</p>

<pre><code class="language-typescript">private data$: Observable&lt;Array&lt;Data&gt;&gt;;
private data2$: Observable&lt;Data2&gt;;

result$: Observable&lt;any&gt;;

doSomething() {
    const dataLength$ = this.data$
        .pipe(
           map(data =&gt; data.length),
        ); 
    const whateverData$ = this.data2$
        .pipe(
           map(val =&gt; this.whateverService.call(val))
        );

	 // we combine the data$ and data2$ with combineLatest
    this.result$ = combineLatest(
        dataLength$,
        whateverData$,
        (val1, val2) =&gt; {
            // handle the values here   
        }
    );
}
</code></pre>

<p>This time, I extracted the nested observables and matched them to local variables first. I then use these newly created local variables to create a new stream using the <code>combineLatest</code> operator. 
By extracting nested observables to a separate variable and naming this new observable properly, the code is easier to understand.</p>

<p><strong>Conclusion</strong></p>

<p>Try to keep the following in mind when writing RxJS code:</p>

<ol>
  <li>Put every operator on a new line.</li>
  <li>Extract functions longer than a line to a nested function.</li>
  <li>Try to avoid working with nested observables.</li>
</ol>


	  ]]></description>
	</item>


</channel>
</rss>
